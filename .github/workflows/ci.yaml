name: CI

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'push' }}

on:
  workflow_dispatch:
    inputs:
      auto_update:
        description: 'Automatically update and push flake.lock'
        type: boolean
        default: true
  push:
    paths:
      - '.github/workflows/ci.yaml'
  schedule:
    - cron: '0 0 * * *'

jobs:
  flake:
    permissions:
      contents: write
      id-token: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b  # v4
        with:
          fetch-depth: 0

      - uses: chainguard-dev/actions/setup-gitsign@b479012116eacde7f895586c17b598f7ba0ee700  # v1.5.9

      - uses: cachix/install-nix-action@ba0dd844c9180cbf77aa72a116d6fbc515d0e87b  # v31
        with:
          extra_nix_config: |
            keep-env-derivations = true
            keep-outputs = true

      - uses: nix-community/cache-nix-action@135667ec418502fa5a3598af6fb9eb733888ce6a  # v6.1.3
        with:
          # restore and save a cache using this key
          primary-key: nix-${{ runner.os }}-${{ hashFiles('**/*.nix', '**/flake.lock') }}
          # if there's no cache hit, restore a cache by this prefix
          restore-prefixes-first-match: nix-${{ runner.os }}-
          # collect garbage until the Nix store size (in bytes) is at most this number
          # before trying to save a new cache
          # 1G = 1073741824
          gc-max-store-size-linux: 1G
          # do purge caches
          purge: true
          # purge all versions of the cache
          purge-prefixes: nix-${{ runner.os }}-
          # created more than this number of seconds ago
          purge-created: 0
          # or, last accessed more than this number of seconds ago
          # relative to the start of the `Post Restore and save Nix store` phase
          purge-last-accessed: 0
          # except any version with the key that is the same as the `primary-key`
          purge-primary-key: never

      - name: Determine if auto-update should run
        id: should-update
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "auto_update=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "auto_update=${{ inputs.auto_update }}" >> "$GITHUB_OUTPUT"
          else
            echo "auto_update=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Update flake.lock
        if: steps.should-update.outputs.auto_update == 'true'
        run: |
          nix flake update --commit-lock-file --option commit-lockfile-summary "chore(deps): flake.lock file maintenance"

      - name: Run flake check
        id: flake-check
        continue-on-error: true
        run: nix flake check --all-systems -L

      - name: Push to main if check passed
        if: steps.should-update.outputs.auto_update == 'true' && steps.flake-check.outcome == 'success'
        run: |
          git push origin HEAD:main

      - name: Create PR if check failed
        if: steps.should-update.outputs.auto_update == 'true' && steps.flake-check.outcome == 'failure'
        uses: peter-evans/create-pull-request@271a8d0340265f705b14b6d32b9829c1cb33d45e  # v7
        with:
          title: "chore(deps): flake.lock file maintenance"
          body: |
            Automated lockfile update.

            ⚠️ **Flake check failed** - manual review required.
          labels: |
            dependencies
            automated
            chore
            needs-review
          reviewers: "0x77dev"
          signoff: true
          sign-commits: true
          branch: chore/deps/flake-lock

      - name: Report check results (push trigger)
        if: steps.should-update.outputs.auto_update == 'false'
        run: |
          if [[ "${{ steps.flake-check.outcome }}" == "success" ]]; then
            echo "Flake check passed"
          else
            exit 1
          fi
